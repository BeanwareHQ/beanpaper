-- beanpaper: a cursed hyprpaper config generator
--
-- Copyright (c) Eason Qin <eason@ezntek.com>, 2025.
--
-- This source code form is licensed under the MIT/Expat license. Visit the
-- root of the project directory for details, or find a digital copy on the OSI
-- website.

local M = {}

---@class Monitor
---@field [1] string (output)
---@field [2] string (path)
---@field contain? boolean (default = false)
---@field tile? boolean (default = false)
---@field useprefix? boolean (default = true)

---@class Config
---@field monitors Monitor[]
---@field prefix? string
---@field ipc? boolean
---@field splash? boolean

---Pretty-prints an error.
---@param txt string
local function err(txt)
    local s = "\27[31;1mERROR: \27[0m" .. txt .. "\n"
    io.stderr:write(s)
    os.exit(1)
end

---Checks if a file exists at path
---@param path string
---@return boolean
local function file_exists(path)
    local fp = io.open(path, "r")
    if fp ~= nil then
        fp:close()
        return true
    else
        return false
    end
end

---Resolves a wallpaper path given a prefix.
---@param mon Monitor
---@param prefix? string
local function resolve_path(mon, prefix)
    local path = mon[2]
    local useprefix = mon.useprefix or true
    if prefix ~= nil and useprefix then
        path = prefix .. '/' .. path
    end
    return path
end

---Generates a string configuration for a monitor table.
---@param mon Monitor
---@param prefix? string
---@return string[]
local function generate_monitor(mon, prefix)
    local output = {}

    local contain = mon.contain or false
    local tile = mon.tile or false

    if contain and tile then
        io.stderr:write(string.format("WARN: cannot have both contain and tile for monitor %s. defaulting to cover\n",
            mon[1]))
    elseif contain then
        table.insert(output, "contain:")
    elseif tile then
        table.insert(output, "tile:")
    end

    local path = mon[2]

    local useprefix = mon.useprefix or true
    if prefix ~= nil and useprefix then
        path = prefix .. "/" .. path
    end

    table.insert(output, path)

    local line = string.format("%s,%s", mon[1], table.concat(output, ""))
    return { line, path }
end

---Gets loaded wallpapers from hyprctl (loaded items stored as keys)
---@return table<string, integer>
local function get_loaded_wallpapers()
    local handle = io.popen("hyprctl hyprpaper listloaded", "r")
    if handle == nil then
        err "failed to query hyprctl for loaded wallpapers"; return {}
    end

    local res = {}
    for line in handle:lines() do
        res[line] = 1
    end

    return res
end

---Validates a configuration before applying
---@param cfg Config
function M.Validate(cfg)
    for _, mon in ipairs(cfg.monitors) do
        local path = resolve_path(mon, cfg.prefix)

        if not file_exists(path) then
            err(string.format("file at %s does not exist", path)); return
        end
    end
end

---Generates a string configuration for a whole config.
---@param cfg Config
function M.Generate(cfg)
    local wallpapers = {}
    local preload = {}

    local ipc = cfg.ipc or true
    local splash = cfg.splash or false

    local header = [[
# ===== GENERATED BY HPG =====
# visit https://github.com/ezntek/beanpaper for details.
# ============================
#
]]
    M.Validate(cfg)

    for _, v in ipairs(cfg.monitors) do
        local mon = generate_monitor(v, cfg.prefix)
        table.insert(wallpapers, "wallpaper = " .. mon[1])

        -- precalculating required wallpapers avoids duplicate preloads
        preload[mon[2]] = 1
    end

    local res = header
    res = res .. "ipc = " .. tostring(ipc) .. "\n"
    res = res .. "splash = " .. tostring(splash) .. "\n"

    for k, _ in pairs(preload) do
        local line = "preload = " .. k .. "\n"
        res = res .. line
    end

    for _, v in ipairs(wallpapers) do
        res = res .. v .. "\n"
    end

    return res
end

---Writes a cfg table to disk, at $HOME/hypr/hyprpaper.conf
---@param cfg Config
function M.ApplyDisk(cfg)
    local cfgpath = os.getenv("XDG_CONFIG_HOME")
    if cfgpath == nil then
        local home = os.getenv("HOME")
        if home == nil then
            err("$HOME does not exist")
        end

        cfgpath = home .. "/.config"
    end

    local path = string.format("%s/hypr/hyprpaper.conf", cfgpath)
    os.execute(string.format("mkdir -p %s/hypr", cfgpath))

    local fp, errmsg = io.open(path, "w")
    if fp == nil then
        err(string.format("failed to open file (%s)", errmsg)); return
    end

    local s = M.Generate(cfg)
    fp:write(s)

    fp:close()
end

---Restarts hyprpaper.
function M.Restart()
    os.execute("pkill hyprpaper")
    os.execute("nohup hyprpaper > /dev/null 2>&1 &")
end

---Applies the configuration over IPC.
---@param cfg Config
function M.ApplyIPC(cfg)
    local loaded = get_loaded_wallpapers()

    for _, mon in ipairs(cfg.monitors) do
        if loaded[mon[2]] == nil then
            local path = resolve_path(mon, cfg.prefix)
            os.execute("hyprctl hyprpaper preload " .. path)
        end
        local gen = generate_monitor(mon, cfg.prefix)
        os.execute("hyprctl hyprpaper wallpaper \"" .. gen .. "\"")
    end

    os.execute("hyprctl hyprpaper unload all")
end

function M.Apply(cfg)
    if not cfg.ipc then
        M.ApplyDisk(cfg)
        M.Restart()
    else
        M.ApplyIPC(cfg)
    end
end

return M
