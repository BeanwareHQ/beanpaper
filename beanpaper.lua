-- beanpaper: a cursed hyprpaper config generator
--
-- Copyright (c) Eason Qin <eason@ezntek.com>, 2025.
--
-- This source code form is licensed under the MIT/Expat license. Visit the
-- root of the project directory for details, or find a digital copy on the OSI
-- website.

local M = {}

---@class Monitor
---@field [1] string (output)
---@field [2] string (path)
---@field contain? boolean (default = false)
---@field tile? boolean (default = false)
---@field useprefix? boolean (default = true)

---@class Config
---@field monitors Monitor[]
---@field prefix? string
---@field ipc? boolean
---@field splash? boolean

---Pretty-prints an error.
---@param txt string
local function err(txt)
    local s = "\27[31;1mERROR: \27[0m" .. txt .. "\n"
    io.stderr:write(s)
    os.exit(1)
end

---Checks if an item is in a table, and returns the index if found.
---@param table any[]
---@param item any
local function contains(table, item)
    for i, v in ipairs(table) do
        if v == item then
            return i
        end
    end
end

---Checks if a file exists at path
---@param path string
---@return boolean
local function exists(path)
    local fp = io.open(path, "r")
    if fp ~= nil then
        fp:close()
        return true
    else
        return false
    end
end

---Generates a string configuration for a monitor table.
---@param mon Monitor
---@param prefix? string
---@return table
local function generate_monitor(mon, prefix)
    local output = {}

    local contain = mon.contain or false
    local tile = mon.tile or false

    if contain and tile then
        io.stderr:write(string.format("WARN: cannot have both contain and tile for monitor %s. defaulting to cover\n",
            mon[1]))
    elseif contain then
        table.insert(output, "contain:")
    elseif tile then
        table.insert(output, "tile:")
    end

    local path = mon[2]

    local useprefix = mon.useprefix or true
    if prefix ~= nil and useprefix then
        path = prefix .. "/" .. path
    end

    table.insert(output, path)

    local line = string.format("wallpaper = %s,%s", mon[1], table.concat(output, ""))
    return { line, path }
end

---Validates a configuration before applying
---@param cfg Config
function M.Validate(cfg)
    for _, mon in ipairs(cfg.monitors) do
        local path = mon[2] -- path
        local useprefix = mon.useprefix or true
        if useprefix and cfg.prefix ~= nil then
            path = cfg.prefix .. "/" .. path
        end

        if not exists(path) then
            err(string.format("file at %s does not exist", path)); return
        end
    end
end

---Generates a string configuration for a whole config.
---@param cfg Config
function M.Generate(cfg)
    local wallpapers = {}
    local preload = {}

    local ipc = cfg.ipc or true
    local splash = cfg.splash or false

    local header = [[
# ===== GENERATED BY HPG =====
# visit https://github.com/ezntek/beanpaper for details.
# ============================
#
]]
    M.Validate(cfg)

    for _, v in ipairs(cfg.monitors) do
        local mon = generate_monitor(v, cfg.prefix)
        table.insert(wallpapers, mon[1])

        -- precalculating required wallpapers avoids duplicate preloads
        preload[mon[2]] = 1
    end

    local res = header
    res = res .. "ipc = " .. tostring(ipc) .. "\n"
    res = res .. "splash = " .. tostring(splash) .. "\n"

    for k, _ in pairs(preload) do
        local line = "preload = " .. k .. "\n"
        res = res .. line
    end

    for _, v in ipairs(wallpapers) do
        res = res .. v .. "\n"
    end

    return res
end

---Writes a cfg table to disk, at $HOME/hypr/hyprpaper.conf
---@param cfg Config
function M.Write(cfg)
    local cfgpath = os.getenv("XDG_CONFIG_HOME")
    if cfgpath == nil then
        local home = os.getenv("HOME")
        if home == nil then
            err("$HOME does not exist")
        end

        cfgpath = home .. "/.config"
    end

    local path = string.format("%s/hypr/hyprpaper.conf", cfgpath)
    os.execute(string.format("mkdir -p %s/hypr", cfgpath))

    local fp, errmsg = io.open(path, "w")
    if fp == nil then
        err(string.format("failed to open file (%s)", errmsg)); return
    end

    local s = M.Generate(cfg)
    fp:write(s)

    fp:close()
end

function M.Apply(cfg)
    M.Write(cfg)
    os.execute("pkill hyprpaper")
    os.execute("nohup hyprpaper > /dev/null 2>&1 &")
end

return M
